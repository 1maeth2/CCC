/*
The following can be viewed as modeling the diffusion of a liquid (e.g. some toxic substance) through a porous 
medium (e.g. the ground) and asking whether it will reach some region (e.g. the water supply). However, we will 
simplify the presentation and pose the problem in just two dimensions.

We are given a (2k+1) by (2k+1) grid, say (G[i,j]: i=-k...k, j=-k...k). You are to write a program to determine 
by simulation, the probability that the boundary can be reached from the starting point (0,0). This is done by 
doing t trials, counting the number that succeed in reaching the boundary, and then dividing this by t to find 
the probabilty of escape. A boundary point is any point G[i,j] such that either i or j is k or -k.

On any one trial, the probability that there is a gap between a grid point (i,j) and its neighbour (i+1,j) is 
determined by p and this probability stays constant for one trial. This is also true for the other three neighbours 
of point (i,j). The value for p is to be input but the probability of a gap will be generated by a random number 
generator.

Note: Efficiency is of some concern here and re-initializing the grid for each trial may be too costly. Programs 
will only be allowed to run for 2 minutes.
*/
#include <iostream>
#include <stdlib.h>
#include <time.h>
#include <vector>
#include <queue>
#include <tuple>

using namespace std;
using ll = long long;

int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

int min(int a, int b){return (a > b ? b : a);}

int solve(){
    int k, t;
    float p;
    cin >> k >> p >> t;
    int size = 2 * k + 1;
    size = size + size - 1;
    int pos = (size + 1) / 2 - 1;
    float escaped = 0;

    srand(time(0));

    for(int i = 0; i < t; i++){
        vector<vector<int>> grid(size, vector<int>(size));
        vector<vector<int>> searched(size, vector<int>(size));
        for(int r = 0; r < size; r++){
            for(int c = 0; c < size; c++){
                if(c % 2 == 1 || r % 2 == 1){
                    grid[r][c] = 1;
                }else{
                    for(int i = 0; i < 4; i++){
                        int dr = r + dir[i][0];
                        int dc = c + dir[i][1];
                        if(dr < 0 || dr >= size || dc < 0 || dc >= size) continue;
                        grid[dr][dc] = rand() % 100 >=  (1 - p) * 100;
                    }
                }
            }
        }

        char black = 254;
        char star = 'O';
        char white = ' ';

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;

        pq.emplace(pos - 1, pos, pos);

        while(!pq.empty()){
            int x = get<2>(pq.top());
            int y = get<1>(pq.top());
            pq.pop();

            if(x <= 0 || x >= size - 1 || y <= 0 || y >= size - 1){
                escaped++;
                break;
            }

            for(int i = 0; i < 4; i++){
                int dy = y + dir[i][0];
                int dx = x + dir[i][1];
                if(dx < 0 || dx >= size || dy < 0 || dy >= size) continue;
                if(!grid[dy][dx] && !searched[dy][dx]){
                    searched[dy][dx] = 1;
                    int dist = min(min(dx - 1, size - dx), min(dy - 1, size - dy));
                    pq.emplace(dist, dy, dx);
                }
            }
        }
    }

    cout << escaped / t << "\n";
}

int main(void){
    int t;
    cin >> t;

    for(int i = 0; i < t; i++){
        solve();
    }

    return 0;
}